/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createForgeErrorFromDiscriminatorValue, createServiceAccountResponseFromDiscriminatorValue, serializeCreateServiceAccountRequest, serializeServiceAccountResponse, type CreateServiceAccountRequest, type ForgeError, type ServiceAccountResponse } from '../models/index.js';
// @ts-ignore
import { type WithServiceAccountItemRequestBuilder, WithServiceAccountItemRequestBuilderNavigationMetadata, WithServiceAccountItemRequestBuilderRequestsMetadata } from './item/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BaseRequestBuilder, type KeysToExcludeForNavigationMetadata, type NavigationMetadata, type Parsable, type ParsableFactory, type ParseNode, type RequestConfiguration, type RequestInformation, type RequestsMetadata, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServiceAccountsGetResponse_serviceAccounts}
 */
// @ts-ignore
export function createServiceAccountsGetResponse_serviceAccountsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServiceAccountsGetResponse_serviceAccounts;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServiceAccountsGetResponse}
 */
// @ts-ignore
export function createServiceAccountsGetResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServiceAccountsGetResponse;
}
/**
 * The deserialization information for the current model
 * @param ServiceAccountsGetResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoServiceAccountsGetResponse(serviceAccountsGetResponse: Partial<ServiceAccountsGetResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "serviceAccounts": n => { serviceAccountsGetResponse.serviceAccounts = n.getCollectionOfObjectValues<ServiceAccountsGetResponse_serviceAccounts>(createServiceAccountsGetResponse_serviceAccountsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ServiceAccountsGetResponse_serviceAccounts The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoServiceAccountsGetResponse_serviceAccounts(serviceAccountsGetResponse_serviceAccounts: Partial<ServiceAccountsGetResponse_serviceAccounts> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accessedAt": n => { serviceAccountsGetResponse_serviceAccounts.accessedAt = n.getDateValue(); },
        "createdAt": n => { serviceAccountsGetResponse_serviceAccounts.createdAt = n.getDateValue(); },
        "createdBy": n => { serviceAccountsGetResponse_serviceAccounts.createdBy = n.getStringValue(); },
        "email": n => { serviceAccountsGetResponse_serviceAccounts.email = n.getStringValue(); },
        "expiresAt": n => { serviceAccountsGetResponse_serviceAccounts.expiresAt = n.getDateValue(); },
        "serviceAccountId": n => { serviceAccountsGetResponse_serviceAccounts.serviceAccountId = n.getStringValue(); },
        "status": n => { serviceAccountsGetResponse_serviceAccounts.status = n.getEnumValue<ServiceAccountsGetResponse_serviceAccounts_status>(ServiceAccountsGetResponse_serviceAccounts_statusObject); },
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ServiceAccountsGetResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeServiceAccountsGetResponse(writer: SerializationWriter, serviceAccountsGetResponse: Partial<ServiceAccountsGetResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!serviceAccountsGetResponse || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<ServiceAccountsGetResponse_serviceAccounts>("serviceAccounts", serviceAccountsGetResponse.serviceAccounts, serializeServiceAccountsGetResponse_serviceAccounts);
    writer.writeAdditionalData(serviceAccountsGetResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param ServiceAccountsGetResponse_serviceAccounts The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeServiceAccountsGetResponse_serviceAccounts(writer: SerializationWriter, serviceAccountsGetResponse_serviceAccounts: Partial<ServiceAccountsGetResponse_serviceAccounts> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!serviceAccountsGetResponse_serviceAccounts || isSerializingDerivedType) { return; }
    writer.writeDateValue("accessedAt", serviceAccountsGetResponse_serviceAccounts.accessedAt);
    writer.writeDateValue("createdAt", serviceAccountsGetResponse_serviceAccounts.createdAt);
    writer.writeStringValue("createdBy", serviceAccountsGetResponse_serviceAccounts.createdBy);
    writer.writeStringValue("email", serviceAccountsGetResponse_serviceAccounts.email);
    writer.writeDateValue("expiresAt", serviceAccountsGetResponse_serviceAccounts.expiresAt);
    writer.writeStringValue("serviceAccountId", serviceAccountsGetResponse_serviceAccounts.serviceAccountId);
    writer.writeEnumValue<ServiceAccountsGetResponse_serviceAccounts_status>("status", serviceAccountsGetResponse_serviceAccounts.status);
    writer.writeAdditionalData(serviceAccountsGetResponse_serviceAccounts.additionalData);
}
export interface ServiceAccountsGetResponse extends AdditionalDataHolder, Parsable {
    /**
     * Contains details of a list of service accounts
     */
    serviceAccounts?: ServiceAccountsGetResponse_serviceAccounts[] | null;
}
export interface ServiceAccountsGetResponse_serviceAccounts extends AdditionalDataHolder, Parsable {
    /**
     * This is the most recent time an access token was generated for this service account, in UTC format
     */
    accessedAt?: Date | null;
    /**
     * The creation time of the service account, in UTC format
     */
    createdAt?: Date | null;
    /**
     * The client ID used to create the service account
     */
    createdBy?: string | null;
    /**
     * The email address of the service account
     */
    email?: string | null;
    /**
     * The expiration time of the service account, in UTC format
     */
    expiresAt?: Date | null;
    /**
     * The Autodesk ID of the service account
     */
    serviceAccountId?: string | null;
    /**
     * The status of the service account
     */
    status?: ServiceAccountsGetResponse_serviceAccounts_status | null;
}
export type ServiceAccountsGetResponse_serviceAccounts_status = (typeof ServiceAccountsGetResponse_serviceAccounts_statusObject)[keyof typeof ServiceAccountsGetResponse_serviceAccounts_statusObject];
/**
 * Builds and executes requests for operations under /service-accounts
 */
export interface ServiceAccountsRequestBuilder extends BaseRequestBuilder<ServiceAccountsRequestBuilder> {
    /**
     * Gets an item from the APS.serviceAccounts.item collection
     * @param serviceAccountId The Autodesk ID of the service account
     * @returns {WithServiceAccountItemRequestBuilder}
     */
     byServiceAccountId(serviceAccountId: string) : WithServiceAccountItemRequestBuilder;
    /**
     * Retrieves all service accounts associated with an application.If an allowlisted Autodesk internal client wants to retrieve all service accounts on behalf of another client, they should pass the `clientId` of the owner as a query parameter.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<ServiceAccountsGetResponse>}
     * @throws {ForgeError} error when the service returns a 401 status code
     * @throws {ForgeError} error when the service returns a 403 status code
     */
     get(requestConfiguration?: RequestConfiguration<ServiceAccountsRequestBuilderGetQueryParameters> | undefined) : Promise<ServiceAccountsGetResponse | undefined>;
    /**
     * Creates a service account. Only [server-to-server application](https://aps.autodesk.com/en/docs/oauth/v2/developers_guide/App-types/Machine-to-machine/) can own service accounts.An application can have up to 10 service accounts at any given time.A name should be provided for the service account with the following restrictions:- Between 5 and 100 characters in length.- Contain only alphanumeric characters and dashes.- Contain at least 1 alphanumeric character.The first name and last name of the service account should also be provided. The restrictions follow the first name and last name restrictions of a real user:- Not be empty.- At most 75 characters.- Contain at least 1 alphanumeric character.- Do not contain inappropriate words.- Do not contain invalid characters. For example:    - Percentage character %  - Forward slash /  - Character pattern of &# (they are allowed separately)Upon a successful response, the operation returns the service account ID and email. The email format in the response is ``<serviceAccountName>@<clientID>.adskserviceaccount.autodesk.com``### Service account creation by an allowlisted Autodesk internal client on behalf of a server-to-server applicationAdditionally, an allowlisted Autodesk internal client can create a service account on behalf of a server-to-server application.To allowlist the client, please reach out to Identity team at [#oxygen](https://autodesk.enterprise.slack.com/archives/C075EFGET) slack channel for assistance.An additional attribute `clientId` is required for the request body and the value should be set to the client ID of the server-to-server application.Allowlisted Autodesk internal clients are not limited to server-to-server applications.
     * @param body The request body for create service account
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<ServiceAccountResponse>}
     * @throws {ForgeError} error when the service returns a 400 status code
     * @throws {ForgeError} error when the service returns a 401 status code
     * @throws {ForgeError} error when the service returns a 403 status code
     */
     post(body: CreateServiceAccountRequest, requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<ServiceAccountResponse | undefined>;
    /**
     * Retrieves all service accounts associated with an application.If an allowlisted Autodesk internal client wants to retrieve all service accounts on behalf of another client, they should pass the `clientId` of the owner as a query parameter.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toGetRequestInformation(requestConfiguration?: RequestConfiguration<ServiceAccountsRequestBuilderGetQueryParameters> | undefined) : RequestInformation;
    /**
     * Creates a service account. Only [server-to-server application](https://aps.autodesk.com/en/docs/oauth/v2/developers_guide/App-types/Machine-to-machine/) can own service accounts.An application can have up to 10 service accounts at any given time.A name should be provided for the service account with the following restrictions:- Between 5 and 100 characters in length.- Contain only alphanumeric characters and dashes.- Contain at least 1 alphanumeric character.The first name and last name of the service account should also be provided. The restrictions follow the first name and last name restrictions of a real user:- Not be empty.- At most 75 characters.- Contain at least 1 alphanumeric character.- Do not contain inappropriate words.- Do not contain invalid characters. For example:    - Percentage character %  - Forward slash /  - Character pattern of &# (they are allowed separately)Upon a successful response, the operation returns the service account ID and email. The email format in the response is ``<serviceAccountName>@<clientID>.adskserviceaccount.autodesk.com``### Service account creation by an allowlisted Autodesk internal client on behalf of a server-to-server applicationAdditionally, an allowlisted Autodesk internal client can create a service account on behalf of a server-to-server application.To allowlist the client, please reach out to Identity team at [#oxygen](https://autodesk.enterprise.slack.com/archives/C075EFGET) slack channel for assistance.An additional attribute `clientId` is required for the request body and the value should be set to the client ID of the server-to-server application.Allowlisted Autodesk internal clients are not limited to server-to-server applications.
     * @param body The request body for create service account
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toPostRequestInformation(body: CreateServiceAccountRequest, requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
}
/**
 * Retrieves all service accounts associated with an application.If an allowlisted Autodesk internal client wants to retrieve all service accounts on behalf of another client, they should pass the `clientId` of the owner as a query parameter.
 */
export interface ServiceAccountsRequestBuilderGetQueryParameters {
    /**
     * The clientId represents the owner of the client. This clientId value should be passed as a query string when an allowlisted Autodesk internal client is making a request on behalf of another client.
     */
    clientId?: string;
}
/**
 * Uri template for the request builder.
 */
export const ServiceAccountsRequestBuilderUriTemplate = "{+baseurl}/service-accounts{?clientId*}";
/**
 * The status of the service account
 */
export const ServiceAccountsGetResponse_serviceAccounts_statusObject = {
    ENABLED: "ENABLED",
    DISABLED: "DISABLED",
    DEACTIVATED: "DEACTIVATED",
} as const;
/**
 * Metadata for all the navigation properties in the request builder.
 */
export const ServiceAccountsRequestBuilderNavigationMetadata: Record<Exclude<keyof ServiceAccountsRequestBuilder, KeysToExcludeForNavigationMetadata>, NavigationMetadata> = {
    byServiceAccountId: {
        requestsMetadata: WithServiceAccountItemRequestBuilderRequestsMetadata,
        navigationMetadata: WithServiceAccountItemRequestBuilderNavigationMetadata,
        pathParametersMappings: ["serviceAccountId"],
    },
};
/**
 * Metadata for all the requests in the request builder.
 */
export const ServiceAccountsRequestBuilderRequestsMetadata: RequestsMetadata = {
    get: {
        uriTemplate: ServiceAccountsRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
            403: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createServiceAccountsGetResponseFromDiscriminatorValue,
    },
    post: {
        uriTemplate: ServiceAccountsRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            400: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
            401: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
            403: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createServiceAccountResponseFromDiscriminatorValue,
        requestBodyContentType: "application/json",
        requestBodySerializer: serializeCreateServiceAccountRequest,
        requestInformationContentSetMethod: "setContentFromParsable",
    },
};
/* tslint:enable */
/* eslint-enable */
