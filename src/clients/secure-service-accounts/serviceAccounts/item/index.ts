/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createForgeErrorFromDiscriminatorValue, serializeEnableServiceAccountRequest, type EnableServiceAccountRequest, type ForgeError } from '../../models/index.js';
// @ts-ignore
import { KeysRequestBuilderNavigationMetadata, KeysRequestBuilderRequestsMetadata, type KeysRequestBuilder } from './keys/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BaseRequestBuilder, type KeysToExcludeForNavigationMetadata, type NavigationMetadata, type Parsable, type ParsableFactory, type ParseNode, type RequestConfiguration, type RequestInformation, type RequestsMetadata, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WithServiceAccountGetResponse}
 */
// @ts-ignore
export function createWithServiceAccountGetResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWithServiceAccountGetResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WithServiceAccountPatchResponse}
 */
// @ts-ignore
export function createWithServiceAccountPatchResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWithServiceAccountPatchResponse;
}
/**
 * The deserialization information for the current model
 * @param WithServiceAccountGetResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWithServiceAccountGetResponse(withServiceAccountGetResponse: Partial<WithServiceAccountGetResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accessedAt": n => { withServiceAccountGetResponse.accessedAt = n.getDateValue(); },
        "createdAt": n => { withServiceAccountGetResponse.createdAt = n.getDateValue(); },
        "createdBy": n => { withServiceAccountGetResponse.createdBy = n.getStringValue(); },
        "email": n => { withServiceAccountGetResponse.email = n.getStringValue(); },
        "expiresAt": n => { withServiceAccountGetResponse.expiresAt = n.getDateValue(); },
        "serviceAccountId": n => { withServiceAccountGetResponse.serviceAccountId = n.getStringValue(); },
        "status": n => { withServiceAccountGetResponse.status = n.getEnumValue<WithServiceAccountGetResponse_status>(WithServiceAccountGetResponse_statusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param WithServiceAccountPatchResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWithServiceAccountPatchResponse(withServiceAccountPatchResponse: Partial<WithServiceAccountPatchResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accessedAt": n => { withServiceAccountPatchResponse.accessedAt = n.getStringValue(); },
        "createdAt": n => { withServiceAccountPatchResponse.createdAt = n.getStringValue(); },
        "createdBy": n => { withServiceAccountPatchResponse.createdBy = n.getStringValue(); },
        "email": n => { withServiceAccountPatchResponse.email = n.getStringValue(); },
        "expiresAt": n => { withServiceAccountPatchResponse.expiresAt = n.getStringValue(); },
        "serviceAccountId": n => { withServiceAccountPatchResponse.serviceAccountId = n.getStringValue(); },
        "status": n => { withServiceAccountPatchResponse.status = n.getEnumValue<WithServiceAccountPatchResponse_status>(WithServiceAccountPatchResponse_statusObject); },
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WithServiceAccountGetResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWithServiceAccountGetResponse(writer: SerializationWriter, withServiceAccountGetResponse: Partial<WithServiceAccountGetResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!withServiceAccountGetResponse || isSerializingDerivedType) { return; }
    writer.writeDateValue("accessedAt", withServiceAccountGetResponse.accessedAt);
    writer.writeDateValue("createdAt", withServiceAccountGetResponse.createdAt);
    writer.writeStringValue("createdBy", withServiceAccountGetResponse.createdBy);
    writer.writeStringValue("email", withServiceAccountGetResponse.email);
    writer.writeDateValue("expiresAt", withServiceAccountGetResponse.expiresAt);
    writer.writeStringValue("serviceAccountId", withServiceAccountGetResponse.serviceAccountId);
    writer.writeEnumValue<WithServiceAccountGetResponse_status>("status", withServiceAccountGetResponse.status);
    writer.writeAdditionalData(withServiceAccountGetResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WithServiceAccountPatchResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWithServiceAccountPatchResponse(writer: SerializationWriter, withServiceAccountPatchResponse: Partial<WithServiceAccountPatchResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!withServiceAccountPatchResponse || isSerializingDerivedType) { return; }
    writer.writeStringValue("accessedAt", withServiceAccountPatchResponse.accessedAt);
    writer.writeStringValue("createdAt", withServiceAccountPatchResponse.createdAt);
    writer.writeStringValue("createdBy", withServiceAccountPatchResponse.createdBy);
    writer.writeStringValue("email", withServiceAccountPatchResponse.email);
    writer.writeStringValue("expiresAt", withServiceAccountPatchResponse.expiresAt);
    writer.writeStringValue("serviceAccountId", withServiceAccountPatchResponse.serviceAccountId);
    writer.writeEnumValue<WithServiceAccountPatchResponse_status>("status", withServiceAccountPatchResponse.status);
    writer.writeAdditionalData(withServiceAccountPatchResponse.additionalData);
}
/**
 * Contains details of a service account
 */
export interface WithServiceAccountGetResponse extends AdditionalDataHolder, Parsable {
    /**
     * This is the most recent time an access token was generated for this service account, in UTC format
     */
    accessedAt?: Date | null;
    /**
     * The creation time of the service account, in UTC format
     */
    createdAt?: Date | null;
    /**
     * The client ID used to create the service account
     */
    createdBy?: string | null;
    /**
     * The email address of the service account
     */
    email?: string | null;
    /**
     * The expiration time of the service account, in UTC format
     */
    expiresAt?: Date | null;
    /**
     * The Autodesk ID of the service account
     */
    serviceAccountId?: string | null;
    /**
     * The status of the service account
     */
    status?: WithServiceAccountGetResponse_status | null;
}
export type WithServiceAccountGetResponse_status = (typeof WithServiceAccountGetResponse_statusObject)[keyof typeof WithServiceAccountGetResponse_statusObject];
/**
 * Builds and executes requests for operations under /service-accounts/{serviceAccountId}
 */
export interface WithServiceAccountItemRequestBuilder extends BaseRequestBuilder<WithServiceAccountItemRequestBuilder> {
    /**
     * The keys property
     */
    get keys(): KeysRequestBuilder;
    /**
     * Deletes an existing service account. When a service account is deleted, all associated keys will also be deleted.Errors:| status code | title                 | detail                                                 ||-------------|-----------------------|-------------------------------------------------------------------|| 401         | unauthorized          | The token has expired or is invalid.                              || 401         | unauthorized          | The token should be a two-legged token.                           | | 404         | not_found             | The service account is not found.                                 |
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @throws {ForgeError} error when the service returns a 401 status code
     * @throws {ForgeError} error when the service returns a 404 status code
     */
     delete(requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<void>;
    /**
     * Retrieves the details for a service account.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<WithServiceAccountGetResponse>}
     * @throws {ForgeError} error when the service returns a 401 status code
     * @throws {ForgeError} error when the service returns a 404 status code
     */
     get(requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<WithServiceAccountGetResponse | undefined>;
    /**
     * Enables or disables a service account.When a service account is disabled state, it loses its capability to manage its service account key. Assertions signed by the key will be treated as invalid.This operation allows enabling a service account that is in a deactivated state.
     * @param body The request body for enable or disable service account
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<WithServiceAccountPatchResponse>}
     * @throws {ForgeError} error when the service returns a 400 status code
     * @throws {ForgeError} error when the service returns a 401 status code
     * @throws {ForgeError} error when the service returns a 404 status code
     */
     patch(body: EnableServiceAccountRequest, requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<WithServiceAccountPatchResponse | undefined>;
    /**
     * Deletes an existing service account. When a service account is deleted, all associated keys will also be deleted.Errors:| status code | title                 | detail                                                 ||-------------|-----------------------|-------------------------------------------------------------------|| 401         | unauthorized          | The token has expired or is invalid.                              || 401         | unauthorized          | The token should be a two-legged token.                           | | 404         | not_found             | The service account is not found.                                 |
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toDeleteRequestInformation(requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
    /**
     * Retrieves the details for a service account.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toGetRequestInformation(requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
    /**
     * Enables or disables a service account.When a service account is disabled state, it loses its capability to manage its service account key. Assertions signed by the key will be treated as invalid.This operation allows enabling a service account that is in a deactivated state.
     * @param body The request body for enable or disable service account
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toPatchRequestInformation(body: EnableServiceAccountRequest, requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
}
/**
 * Contains details of a service account
 */
export interface WithServiceAccountPatchResponse extends AdditionalDataHolder, Parsable {
    /**
     * This is the most recent time an access token was generated for this service account
     */
    accessedAt?: string | null;
    /**
     * The creation time of the service account
     */
    createdAt?: string | null;
    /**
     * The client ID used to create the service account
     */
    createdBy?: string | null;
    /**
     * The email address of the service account
     */
    email?: string | null;
    /**
     * The expiration time of the service account
     */
    expiresAt?: string | null;
    /**
     * The Autodesk ID of the service account
     */
    serviceAccountId?: string | null;
    /**
     * The status of the service account
     */
    status?: WithServiceAccountPatchResponse_status | null;
}
export type WithServiceAccountPatchResponse_status = (typeof WithServiceAccountPatchResponse_statusObject)[keyof typeof WithServiceAccountPatchResponse_statusObject];
/**
 * Uri template for the request builder.
 */
export const WithServiceAccountItemRequestBuilderUriTemplate = "{+baseurl}/service-accounts/{serviceAccountId}";
/**
 * The status of the service account
 */
export const WithServiceAccountGetResponse_statusObject = {
    ENABLED: "ENABLED",
    DISABLED: "DISABLED",
    DEACTIVATED: "DEACTIVATED",
} as const;
/**
 * Metadata for all the navigation properties in the request builder.
 */
export const WithServiceAccountItemRequestBuilderNavigationMetadata: Record<Exclude<keyof WithServiceAccountItemRequestBuilder, KeysToExcludeForNavigationMetadata>, NavigationMetadata> = {
    keys: {
        requestsMetadata: KeysRequestBuilderRequestsMetadata,
        navigationMetadata: KeysRequestBuilderNavigationMetadata,
    },
};
/**
 * Metadata for all the requests in the request builder.
 */
export const WithServiceAccountItemRequestBuilderRequestsMetadata: RequestsMetadata = {
    delete: {
        uriTemplate: WithServiceAccountItemRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
            404: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "sendNoResponseContent",
    },
    get: {
        uriTemplate: WithServiceAccountItemRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
            404: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createWithServiceAccountGetResponseFromDiscriminatorValue,
    },
    patch: {
        uriTemplate: WithServiceAccountItemRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            400: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
            401: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
            404: createForgeErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createWithServiceAccountPatchResponseFromDiscriminatorValue,
        requestBodyContentType: "application/json",
        requestBodySerializer: serializeEnableServiceAccountRequest,
        requestInformationContentSetMethod: "setContentFromParsable",
    },
};
/**
 * The status of the service account
 */
export const WithServiceAccountPatchResponse_statusObject = {
    ENABLED: "ENABLED",
    DISABLED: "DISABLED",
    DEACTIVATED: "DEACTIVATED",
} as const;
/* tslint:enable */
/* eslint-enable */
